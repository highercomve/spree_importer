SpreeImporter
=============

Import tool for Spree Product.

Installation
------------

Add spree_importer to your Gemfile:

```ruby
gem 'spree_importer'
```

Bundle your dependencies and run the installation generator:

```shell
bundle
bundle exec rails g spree_importer:install
```



Uso
---

Usted debe definir un decorador del SpreeImporter::Importer, y debera crear un inicializador que como el siguiente:

```ruby
 module SpreeImporter
  Importer.class_eval do
    def initialize filename, filepath
      @filename = filename
      @filepath = filepath

      @spreadsheet = nil

      @product_identifier = ProductIdentifier.new('A', :name)

      @mappers = []
      @mappers << Mappers::ProductMapper.new('A', :name)
      @mappers << Mappers::ProductMapper.new('B', :sku)
      @mappers << Mappers::ProductMapper.new('C', :prototype_id)
      @mappers << Mappers::ProductMapper.new('D', :price)
      @mappers << Mappers::ProductMapper.new('E', :available_on)
      @mappers << Mappers::ProductMapper.new('F', :shipping_category_id)
    end
  end
end
```

* En este se define el archivo a leer
* Una variable para almacenar el los datos del archivo
* Una instancia de la clase que permite verificar el el producto existe
* Un arreglo con instancia de que heredan de la clase Mappers::BaseMapper

La logica se base en diferentes `Mappers` un mapper esta encargado de mapear el resultado de una columna un alguno de los
modelo de spree, por tanto un mapper requiere para funcionar,

1.- La columna que va a mappear
2.- Nombre del attributo en el modelo que esta mapeando
3.- (Opcional) de forma opcional, es posible proporcionar al constructor del mapper un parametros de una clase esecializada
para formatear la data segun se requiera, lo unico importante es que esta clase responda con el metodo de clase `parse` y como
parametro el valor que se requiere formatear.

De esta forma usted tiene una columna available_on con formato `9/7/14 0:00`, usted puede definir si importer de la siguiente forma:

```ruby
module SpreeImporter
  class DateTimeParser
    def self.parse value
      DateTime.strptime(value, "%d/%m/%y").to_s
    end
  end
end

module SpreeImporter
  Importer.class_eval do
    def initialize filename, filepath
      ...
      @mappers << Mappers::ProductMapper.new('E', :available_on, DateTimeParser))
      ...
    end
  end
end
```


ToDo
----

* SpreeImporter::Importer deberia ser un modulo o una clase, de forma de permitir tener mas de una clase de import, de esta forma podriamos permitir tener diferentes mecanismos de carga masiva, ej: productos, taxons, prototipos, propiedades, etc.
* Mejorar default_hash para quitar componente no necesarias y agregar lo necesario para futuros reviews.
* Detectar Mappers de forma automatica en funcion del nombre de las columnas, idealmente:
  * poder detectar automaticamente las columnas
  * poder definir/registrar Mappers customs para deteccion automatica
  * poder sobreescribir detecciÃ³n automatica
* Quitar dependencia de sidekiq, (ver: activejob)
* Bucket para obtener images (AS3, dropbox, etc)
* Importer puede ser una clase, de esta forma se puede:
  * recargar la pagina para tener una status de progreso
  * tener un log con los problemas en cada linea
  * se podria volver a cargar la misma linea en otro momento



Testing
-------

First bundle your dependencies, then run `rake`. `rake` will default to building the dummy app if it does not exist, then it will run specs. The dummy app can be regenerated by using `rake test_app`.

```shell
bundle
bundle exec rake
```

When testing your applications integration with this extension you may use it's factories.
Simply add this require statement to your spec_helper:

```ruby
require 'spree_importer/factories'
```

Copyright (c) 2014 [Acid Labs](http://acid.cl), all rigths reserved.
